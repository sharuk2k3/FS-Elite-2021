'''

A device is secured with a digital screen, 
The digital screen is made up of a 3*3 grid like below:
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

The code is generated by connecting the keys in a valid way using the grid.

Rules to create the valid codes are as follows:
	- Each code must consist of atleast m keys and atmost n keys.
	- All the keys must be distinct.
	- If the line connecting two consecutive keys 'A','B' in the code passes 
	  through any other key C, then 'C' must have already connected priorly, 
	  as a part of the code. No jumps through a key which is not part of 
	  the code are allowed.
	- The order of keys used matters.
 
You will be given two integers m and n, where 1 ≤ m ≤ n ≤ 9, 
Your task is to count the total number of valid codes can be created to 
sefeguard the device, which consist of minimum of m keys and maximum n keys. 

Examples of valid and invalid codes:
	Invalid code: 1 - 2 - 7 - 9
	Line 7 - 9, passes through key 8 which has not been part of the code.
	i.e., 1 - 2 - 7 - 9 - 8 is also an invalid code.

	Invalid code: 1 - 8 - 3 - 7
	Line 3 - 7 passes through key 5 which has not been part of the code.

	Valid code: 5 - 7 - 4 - 6 - 9   
	Line 4 - 6 is valid because it passes through key 5, which has been part 
	of the code

	Valid code: 4 - 5 - 6 - 3 - 7 - 2
	Line 3 - 7 is valid because it passes through key 5, which has been part 
	of the code

Input Format:
-------------
Two space separated integers M and N.

Output Format:
--------------
Print an integer, number of valid codes created using the digital screen.


Sample Input-1:
---------------
1 1

Sample Output-1:
----------------
9


Sample Input-2:
---------------
1 2

Sample Output-2:
----------------
65


'''


'''
def numberOfPatterns(m, n):
    used = [False] * 9
    res = 0
    for l in range(m, n + 1):
        res += calc_patterns(used, -1, l)
        used = [False] * 9
    return res

def is_valid( used, index, last):
    # markded
    if used[index]:
        return False
    # first digit
    if last == -1:
        return True
    # adjacent cells (in a row or in a column)
    if (last + index) % 2 == 1:
        return True
    mid = (last + index) / 2
    if mid == 4:
        return used[mid]
    # adjacent cells on diagonal
    if (index % 3 != last % 3) and (index / 3 != last / 3):
        return True
    # all other cells which are not adjacent
    return used[mid]

def calc_patterns( used, last, length):
    if length == 0:
        return 1
    res = 0
    for i in range(9):
        if is_valid(used, i, last):
            used[i] = True
            res += calc_patterns(used, i, length - 1)
            used[i] = False
    return res
    
m,n=map(int,input().split())
print(numberOfPatterns(m, n))
'''

def numberOfPatterns( m, n):
    def merge(used, i):
        return used | (1 << i)

    def number_of_keys(i):
        number = 0
        while i > 0:
            i &= i - 1
            number += 1
        return number

    def exclude(used, i):
        return used & ~(1 << i)

    def contain(used, i):
        return bool(used & (1 << i))

    def convert(i, j):
        return 3 * i + j

        # dp[i][j]: i is the set of the numbers in binary representation,
        #            d[i][j] is the number of ways ending with the number j.
    dp = [[0] * 9 for _ in range(1 << 9)]
    for i in range(9):
        dp[merge(0, i)][i] = 1

    res = 0
    for used in range(len(dp)):
        number = number_of_keys(used)
        if number > n:
            continue

        for i in range(9):
            if not contain(used, i):
                continue

            x1, y1 = divmod(i, 3)
            for j in range(9):
                if i == j or not contain(used, j):
                    continue

                x2, y2 = divmod(j, 3)
                if ((x1 == x2 and abs(y1 - y2) == 2) or
                    (y1 == y2 and abs(x1 - x2) == 2) or
                    (abs(x1 - x2) == 2 and abs(y1 - y2) == 2)) and \
                      not contain(used,
                                  convert((x1 + x2) // 2, (y1 + y2) // 2)):
                        continue

                dp[used][i] += dp[exclude(used, i)][j]

            if m <= number <= n:
                res += dp[used][i]

    return res
m,n=map(int,input().split())
print(numberOfPatterns( m, n))

